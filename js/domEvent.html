<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解dom事件 | 技术分享</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.6c495ada.css" as="style"><link rel="preload" href="/assets/js/app.a5f12e3f.js" as="script"><link rel="preload" href="/assets/js/2.012767ec.js" as="script"><link rel="preload" href="/assets/js/31.2617bdab.js" as="script"><link rel="prefetch" href="/assets/js/10.11845e8d.js"><link rel="prefetch" href="/assets/js/11.cda97d54.js"><link rel="prefetch" href="/assets/js/12.26a5fa04.js"><link rel="prefetch" href="/assets/js/13.e5412671.js"><link rel="prefetch" href="/assets/js/14.ce9d5328.js"><link rel="prefetch" href="/assets/js/15.36883b01.js"><link rel="prefetch" href="/assets/js/16.eab308d6.js"><link rel="prefetch" href="/assets/js/17.1bedb10d.js"><link rel="prefetch" href="/assets/js/18.86655160.js"><link rel="prefetch" href="/assets/js/19.3c121154.js"><link rel="prefetch" href="/assets/js/20.66014292.js"><link rel="prefetch" href="/assets/js/21.9b704246.js"><link rel="prefetch" href="/assets/js/22.79fb5d61.js"><link rel="prefetch" href="/assets/js/23.dd836561.js"><link rel="prefetch" href="/assets/js/24.b2cb9a0e.js"><link rel="prefetch" href="/assets/js/25.7ded2382.js"><link rel="prefetch" href="/assets/js/26.a858d3c2.js"><link rel="prefetch" href="/assets/js/27.6554e35b.js"><link rel="prefetch" href="/assets/js/28.dc59e70d.js"><link rel="prefetch" href="/assets/js/29.8ae6ac0b.js"><link rel="prefetch" href="/assets/js/3.91688b6b.js"><link rel="prefetch" href="/assets/js/30.158b3697.js"><link rel="prefetch" href="/assets/js/32.12fd8296.js"><link rel="prefetch" href="/assets/js/33.1fb3a562.js"><link rel="prefetch" href="/assets/js/34.861e72c8.js"><link rel="prefetch" href="/assets/js/35.9656c028.js"><link rel="prefetch" href="/assets/js/36.a8eff3ec.js"><link rel="prefetch" href="/assets/js/37.09f7437c.js"><link rel="prefetch" href="/assets/js/38.0bd7aae9.js"><link rel="prefetch" href="/assets/js/39.c309197e.js"><link rel="prefetch" href="/assets/js/4.c85e84b2.js"><link rel="prefetch" href="/assets/js/40.78f76cb0.js"><link rel="prefetch" href="/assets/js/41.fd73aeb6.js"><link rel="prefetch" href="/assets/js/42.adcd28da.js"><link rel="prefetch" href="/assets/js/43.dad3d073.js"><link rel="prefetch" href="/assets/js/44.5ee75599.js"><link rel="prefetch" href="/assets/js/45.2c4ca62f.js"><link rel="prefetch" href="/assets/js/46.5cd263f5.js"><link rel="prefetch" href="/assets/js/47.e48a9193.js"><link rel="prefetch" href="/assets/js/5.0e5ac005.js"><link rel="prefetch" href="/assets/js/6.c4a7d53e.js"><link rel="prefetch" href="/assets/js/7.dbe0e90b.js"><link rel="prefetch" href="/assets/js/8.880eb801.js"><link rel="prefetch" href="/assets/js/9.5c5f6e8b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6c495ada.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术分享</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">技术分享这件小事</a><ul class="sidebar-sub-headers"></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/jsFunction.html" class="sidebar-link">js 高级技巧</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/domEvent.html" class="active sidebar-link">理解dom事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件简介" class="sidebar-link">DOM事件简介</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件模型" class="sidebar-link">DOM事件模型</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件绑定" class="sidebar-link">DOM事件绑定</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件的传播" class="sidebar-link">DOM事件的传播</a></li></ul></li><li><a href="/js/domEventPatch.html" class="sidebar-link">封装通用事件绑定函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/delayLoad.html" class="sidebar-link">js延迟加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/copy.html" class="sidebar-link">js深浅拷贝</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/throttle.html" class="sidebar-link">js节流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/throttle.html#函数防抖-debounce" class="sidebar-link">函数防抖(debounce)</a></li><li class="sidebar-sub-header"><a href="/js/throttle.html#函数节流-throttle" class="sidebar-link">函数节流(throttle)</a></li></ul></li><li><a href="/js/curry.html" class="sidebar-link">函数柯里化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/eventLoop.html" class="sidebar-link">理解浏览器的event loop</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/context.html" class="sidebar-link">Js的执行上下文和执行栈</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/this.html" class="sidebar-link">Js的this关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/stricMode.html" class="sidebar-link">理解严格模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/prototype.html" class="sidebar-link">理解js原型链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/inherit.html" class="sidebar-link">理解js继承</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>common</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>design</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="理解dom事件"><a href="#理解dom事件" aria-hidden="true" class="header-anchor">#</a> 理解dom事件</h1> <p><code>2020-04-08</code>, 修改于<code>2020-04-10</code></p> <p>修改于<code>2020-04-24</code>: 补充了最后一个引用相关的知识点。</p> <blockquote><p>学习计划开始<code>第九天</code>，今天的目标是深入理解<code>dom事件</code>。</p></blockquote> <h2 id="dom事件简介"><a href="#dom事件简介" aria-hidden="true" class="header-anchor">#</a> DOM事件简介</h2> <blockquote><p>事件是您在编程时系统内的发生的动作或者发生的事情，系统通过它来告诉您在您愿意的情况下您可以以某种方式对它做出回应。</p></blockquote> <p>一般来说，事件来自输入设备，输入设备有三种： 键盘，鼠标，触摸屏。</p> <p><code>触摸屏和鼠标又有一定的共性，它们被称作 pointer 设备，所谓 pointer 设备，是指它的输入最终会被抽象成屏幕上面的一个点。</code>也有一定区别，它们的精度、反应时间和支持的点的数量都不一样。</p> <blockquote><p>点击事件来自触摸屏或者鼠标，鼠标点击并没有位置信息，但是一般操作系统会根据位移的累积计算出来，跟触摸屏一样，提供一个坐标给浏览器。把这个坐标转换为具体的元素上事件的过程，就是捕获过程了。而冒泡过程，则是符合人类理解逻辑的：当你按电视机开关时，你也按到了电视机。</p></blockquote> <p>为什么会有捕获过程和冒泡过程?</p> <blockquote><p>捕获是计算机处理事件的逻辑，而冒泡是人类处理事件的逻辑.</p></blockquote> <p><strong>监听事件</strong></p> <blockquote><p>在Web应用程序或Web站点中，事件就是告诉浏览器发生了什么事情。浏览器会以此为据，给与响应。（事件是客户端的一种处理机制，与javascript语言不存在直接联系，联系的建立是依靠客户端来实现的，事件机制本身并不是javascript的内容）。客户端浏览器的交互模式的实现实际上是基于javascript的异步事件驱动模型编程的。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;);
</code></pre></div><p><code>参数含义</code></p> <ul><li><code>element</code>: 要监听事件的元素或对象，通常是一个DOM元素，但它也可以是document，window或任何其他刚好触发事件的对象</li> <li><code>event-name(string)</code>: 你想监听的事件的名称或类型。它可以是任何的标准DOM事件,当然也可以是你自己定义的事件名称。</li> <li><code>callback(function)</code>: 这个回调函数会在事件触发的时候被调用。相应的事件对象，以及事件的数据，会被作为第一个参数传入这个函数。这个函数也被称为事件处理程序。</li> <li><code>use-capture(boolean)</code>: 这个参数决定了回调函数(callback)是否在“捕获(capture)”阶段被触发。</li></ul> <p><code>事件目标</code>: 就是发生事件的对象或者与该事件相关的对象。其可以是一个button，一个div，一个input，甚至可以是document或window。而其确定是需要由需求来决定的。</p> <p><code>事件类型</code>:</p> <ul><li>鼠标事件，比如mouseover、mouseout、click等</li> <li>键盘事件，比如keydown、keypress、keyup等</li> <li>触屏事件，比如touchstart、touchmove、touchenter等</li> <li>window事件，比如load、unload等</li></ul> <p><code>事件处理程序</code>: 事件处理程序是事件目标在响应时指定的事件类型时需要执行的程序。</p> <p><code>事件捕获</code>: 事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前就捕获它。</p> <p>事件绑定的第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。</p> <ul><li>once：只执行一次。</li> <li>passive：承诺此事件监听不会调用 preventDefault，这有助于性能。</li> <li>useCapture：是否捕获（否则冒泡）。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousedown&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;key1&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;i&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousedown&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;key2&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousedown&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;key11&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>

document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;i&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;mousedown&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;key22&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token comment">// 在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。</span>
<span class="token comment">// &quot;key1&quot; &quot;key2&quot; &quot;key22&quot; &quot;key11&quot; 捕获和冒泡发生的完整顺序</span>
</code></pre></div><p>大部分业务开发者不需要关心捕获过程。除非你是组件或者库的使用者，那就总是需要关心冒泡和捕获了。</p> <p>键盘事件是由焦点系统控制的。焦点系统认为整个 UI 系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素。随着输入设备的不断丰富，还有很多新的事件加入，如 Geolocation 和陀螺仪等。</p> <h2 id="dom事件模型"><a href="#dom事件模型" aria-hidden="true" class="header-anchor">#</a> DOM事件模型</h2> <h3 id="基本事件模型"><a href="#基本事件模型" aria-hidden="true" class="header-anchor">#</a> 基本事件模型</h3> <blockquote><p>在JavaScript中，事件在未得到标准化之前，各浏览器就有一个事件模型 —— 基本事件模型（Basic Event Model）。在基本事件模型中，要在某个事件发生时，调用指定的函数。</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// window的load事件发生时要做的事情... }</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- HTML --&gt;</span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>Click Me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
// Script
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">let</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> 
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> handler
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>像这样的做法，被称为传统模型（Traditional Model）或传统注册模型（Traditional Registration Model）。这种事件模型也被称为DOM0级模型。</p></blockquote> <p><strong>缺点</strong>: 只能注册一个事件处理程序</p> <p><strong>解除绑定</strong>: 在基本事件模型中，如果要移除监听函数，可以通过给其事件赋值null来实现。</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><h3 id="dom-level-2模型"><a href="#dom-level-2模型" aria-hidden="true" class="header-anchor">#</a> DOM Level 2模型</h3> <blockquote><p>DOM level 2模型属于W3C标准模型，现代浏览器都支持该模型。在该事件模型中，一次事件共有三个过程：</p></blockquote> <ul><li><strong>事件捕获阶段（Capturing Phase）</strong>：事件从document一直向下传播到目标元素，依次检查经历过的节点是否绑定了事处监听函数（事件处理程序），如果有则执行，反之不执行</li> <li><strong>事件处理阶段（Target Phase）</strong>：事件到达目标元素，触发目标元素的监听函数</li> <li><strong>事件冒泡阶段（Bubbling Phase）</strong>：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行，反之不执行。</li></ul> <blockquote><p><strong>简而言之</strong>：事件一开始从文档的根节点流向目标对象（捕获阶段），然后在目标对向上被触发（目标阶段），之后再回溯到文档的根节点（冒泡阶段）。</p></blockquote> <p>要注册事件，必须使用<code>addEventListener()</code>方法。在DOM Level 2事件模型中，可以注册多个事件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">handler1</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'handler1:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> 
<span class="token keyword">let</span> <span class="token function-variable function">handler2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'handler2'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> 
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handler1<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> 
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handler2<span class="token punctuation">,</span> <span class="token boolean">true</span>
</code></pre></div><p><strong>移除事件处理程序</strong>: 可以使用<code>removeEventListener()</code>方法。</p> <p><strong>注意</strong>: 低于IE9的浏览器是不支持这种事件模型。所以在JavaScript事件模型中，还有第三种事件模型 —— IE事件模型。</p> <h3 id="ie事件模型"><a href="#ie事件模型" aria-hidden="true" class="header-anchor">#</a> IE事件模型</h3> <blockquote><p>在IE事件模型中，需要使用attachEvent()和detachEvent()方法来触发事件和移除事件。在IE事件模型中，其有两个过程：</p></blockquote> <ul><li><strong>事件处理阶段（Target Phase）</strong>：事件到达目标元素，触发目标元素的监听函数</li> <li><strong>事件冒泡阶段（Bubbling Phase）</strong>：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li></ul> <h3 id="dom-level-3事件模型"><a href="#dom-level-3事件模型" aria-hidden="true" class="header-anchor">#</a> DOM Level 3事件模型</h3> <blockquote><p>DOM Level 3事件模型是DOM Level 2的事件模型的升级版，在DOM Level 2事件模型的基础上添加了更多的事件类型：</p></blockquote> <ul><li><strong>UI事件</strong>：当用户与页面上的元素交互时触发，如：<code>load</code>、<code>scroll</code></li> <li><strong>焦点事件</strong>：当元素获得或失去焦点时触发，如：<code>blur</code>、<code>focus</code></li> <li><strong>鼠标事件</strong>：当用户通过鼠标在页面执行操作时触发如：<code>dbclick</code>、<code>mouseup</code></li> <li><strong>滚轮事件</strong>：当使用鼠标滚轮或类似设备时触发，如：<code>mousewheel</code></li> <li><strong>文本事件</strong>：当在文档中输入文本时触发，如：<code>input</code>、<code>change</code></li> <li><strong>键盘事件</strong>：当用户通过键盘在页面上执行操作时触发，如：<code>keydown</code>、<code>keypress</code></li> <li><strong>合成事件</strong>：当为IME（输入法编辑器）输入字符时触发，如：<code>compositionstart</code></li> <li><strong>变动事件</strong>：当底层DOM结构发生变化时触发，如：<code>DOMsubtreeModified</code></li></ul> <blockquote><p>同时DOM3级事件也允许使用者自定义一些事件。在自定义事件称之为自定义事件模型。</p></blockquote> <h3 id="自定义事件模型"><a href="#自定义事件模型" aria-hidden="true" class="header-anchor">#</a> 自定义事件模型</h3> <blockquote><p>事件模型的实现从设计模式的角度来看，是一种观察者模式或者也叫发布订阅模式，订阅者订阅一个消息，发布者发布这个消息，订阅者收到消息，这是一种数据流动的方式，使用这个模式的好处是，可以有多个订阅者，一个发布者，发布一条消息，可被多个订阅者收到。可以自己模拟一个类似这样的类。nodejs也有类似的实现。很多前端框架（比如Backbone.js）都是重度基于事件的，使用发布/订阅（Publish &amp; Subscribe）的方式来处理跨模块间的通信，这点跟DOM非常相似。解耦很好。复杂度被封装隐藏在一套简单的接口背后。</p></blockquote> <p>由于DOM API 中的事件并不能用于普通对象，我们只能在 DOM 元素上使用自定义事件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> evt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">&quot;look&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">&quot;bubbles&quot;</span><span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&quot;cancelable&quot;</span><span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>这里使用 Event 构造器来创造了一个新的事件，然后调用 dispatchEvent 来在特定元素上触发。我们可以给这个 Event 添加自定义属性、方法。旧的自定义事件方法（使用 document.createEvent 和 initEvent）已经被废弃。</p></blockquote> <h2 id="dom事件绑定"><a href="#dom事件绑定" aria-hidden="true" class="header-anchor">#</a> DOM事件绑定</h2> <blockquote><p>在JavaScript中，给DOM元素绑定事件主要分为两大类：<strong>HTML中直接绑定</strong>和<strong>JavaScript</strong>中绑定。</p></blockquote> <h3 id="hmtl中直接绑定"><a href="#hmtl中直接绑定" aria-hidden="true" class="header-anchor">#</a> HMTL中直接绑定</h3> <blockquote><p>在HTML中绑定事件叫做内联绑定事件。其使用方式非常的简单，就是在HTML的元素中使用event属性来绑定事件，比如onclick这样的on(type)属性，其中type指的就是DOM的事件（比如click），它可以给这个DOM元素绑定一个类型的事件。比如，要为button元素绑定一个click事件</p></blockquote> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>show();<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Click Me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> 
  <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Show Me!'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> 
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><blockquote><p>这种方式对应的也是<code>DOM Level0</code> 模型中的事件绑定方式。虽然这种方式也能正常的DOM事件绑定方式，但这种方法是非常不鼓励的。因为它是一种非常不灵活的事件绑定方式，它将HTML结构和JavaScript混合在一起。</p></blockquote> <h3 id="javascript中绑定dom事件"><a href="#javascript中绑定dom事件" aria-hidden="true" class="header-anchor">#</a> JavaScript中绑定DOM事件</h3> <ul><li>element.on(type) = listener (DOM Level1)</li> <li>element.addEventListener(type, listener, useCapture) (DOM Level2)</li></ul> <p><code>第一种: DOM level1</code></p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>Click Me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Show Me!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
  <span class="token keyword">let</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span> 
  btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> show<span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>与内联绑定的区别:</p> <blockquote><p>内联方式赋值的是一段JavaScript字符串，而这里赋值的是一个函数，它可以接受以一个参数event，这个参数是点击的事件对象。</p></blockquote> <p><code>本质</code></p> <blockquote><ul><li>它的本质就是给HTML元素添加相应的属性</li> <li>它的事件处理程序（绑定的事件）在执行时，其中的this指向当前的元素</li> <li>该方式不会做同一元素的同类型事件绑定累加。也就是当你在同一个元素上多次绑定相同类型的监听函数时，后者会覆盖前者著作权归作者所有。</li></ul></blockquote> <p><code>第二种: DOM level2</code>
具体使用前面介绍过。这里作其他补充。</p> <blockquote><ul><li>使用addEventListener可以给同一个DOM元素绑定多个函数，并且它的执行顺序将按照绑定的顺序执行！</li> <li>使用addEventListener可以给一个DOM元素绑定同一个函数，最多只能绑定useCapture类型不同的两次！
总结:</li> <li>当用户进行一个操作时，浏览器会根据该操作依次触发相应的事件监听函数。</li> <li>当同一个元素上绑定了多次同类型事件，比如button元素上做了多次click事件，那么遵循“先绑定先触发”的原则，而且最多只能绑定useCapture类型不同的两次</li> <li>它的事件处理程序在执行时，其中this指向当前的元素</li></ul></blockquote> <h3 id="事件对象"><a href="#事件对象" aria-hidden="true" class="header-anchor">#</a> 事件对象</h3> <blockquote><p>DOM事件调用处理程序时，可以给这个处理程序传一个参数，比如event参数。事实上，当事件发生时，浏览器会创建一个事件对象，将详细信息放入这个对象当中，并将其作为参数传递给处理程序。Event对象在event第一次触发的时候被创建出来，并且一直伴随着事件在DOM结构中流转的整个生命周期。event对象会被作为第一个参数传递给事件监听的回调函数。我们可以通过这个event对象来获取到大量当前事件相关的信息：</p></blockquote> <ul><li><strong>type (String)</strong>：事件的名称</li> <li><strong>target (node)</strong>：事件起源的DOM节点</li> <li><strong>currentTarget?(node)</strong>：当前回调函数被触发的DOM节点（后面会做比较详细的介绍）</li> <li><strong>bubbles (boolean)</strong>：指明这个事件是否是一个冒泡事件（接下来会做解释）</li> <li><strong>preventDefault(function)</strong>：这个方法将阻止浏览器中用户代理对当前事件的相关默认行为被触发。比如阻止a元素的click事件加载一个新的页面</li> <li><strong>stopPropagation (function)</strong>：这个方法将阻止当前事件链上后面的元素的回调函数被触发，当前节点上针对此事件的其他回调函数依然会被触发。（我们稍后会详细介绍。）</li> <li><strong>stopImmediatePropagation (function)</strong>：这个方法将阻止当前事件链上所有的回调函数被触发，也包括当前节点上针对此事件已绑定的其他回调函数。</li> <li><strong>cancelable (boolean)</strong>：这个变量指明这个事件的默认行为是否可以通过调用event.preventDefault来阻止。也就是说，只有cancelable为true的时候，调用event.preventDefault才能生效。</li> <li><strong>defaultPrevented (boolean)</strong>：这个状态变量表明当前事件对象的preventDefault方法是否被调用过</li> <li><strong>isTrusted (boolean)</strong>：如果一个事件是由设备本身（如浏览器）触发的，而不是通过JavaScript模拟合成的，那个这个事件被称为可信任的(trusted)。</li> <li><strong>eventPhase (number)</strong>：这个数字变量表示当前这个事件所处的阶段(phase):none(0), capture(1),target(2),bubbling(3)。我们会在下一个部分介绍事件的各个阶段</li> <li><strong>timestamp (number)</strong>：事件发生的时间</li></ul> <p>还有针对特定event的。例如鼠标事件包含clientX和clientY属性来表明鼠标在当前视窗的位置。</p> <h3 id="对象处理程序：handleevent"><a href="#对象处理程序：handleevent" aria-hidden="true" class="header-anchor">#</a> 对象处理程序：handleEvent</h3> <blockquote><p>我们可以使用addEventListener将对象指定为事件处理程序。当一个事件发生时，它的handleEvent方法也随之被调用。换句话说，当addEventListener接收到一个对象作为处理程序时，它在发生事件时调用object.handleEvent(event)。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> 
  <span class="token function">handleEvent</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">.</span>type<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">.</span>currentTarget<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Coordinates: (</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">.</span>clientX<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">.</span>clientY<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">)</span> 
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="选择哪种使用"><a href="#选择哪种使用" aria-hidden="true" class="header-anchor">#</a> 选择哪种使用</h3> <ul><li>不应该使用HTML事件处理程序属性，因为这些属性已经过时了，而且也是不好的做法</li> <li>事件处理程序属性功能和选会更少，但是具有更好的跨浏览器兼容性。不能为特定事件分配多个处理程序。</li> <li>DOM Level2 事件（addEventListener）更强大，但也可以变得更加复杂，并且支持不足（IE9以下不支持)，支持绑定多个处理程序，支持handleEvent。</li></ul> <h2 id="dom事件的传播"><a href="#dom事件的传播" aria-hidden="true" class="header-anchor">#</a> DOM事件的传播</h2> <blockquote><p>是事件冒泡和事件捕获的总称。W3C规范中定义了三个事件阶段，依次是<strong>捕获阶段</strong>、<strong>目标阶段</strong>和<strong>冒泡阶段</strong>。事件对象按照上图的传播路径依次完成这些阶段。如果某个阶段不支持或事件对象的传播被终止，那么该阶段就会被跳过。</p></blockquote> <ul><li><strong>捕获阶段</strong>：在事件对象到达事件目标之前，事件对象必须从<code>window</code>经过目标的祖先节点传播到事件目标。这个阶段被我们称之为捕获阶段。在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件</li> <li><strong>目标阶段</strong>：事件对象到达其事件目标。这个阶段被我们称为目标阶段。一旦事件对象到达事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到达此阶段时就会终止传播</li> <li><strong>冒泡阶段</strong>：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到<code>window</code>。这个阶段被称之为冒泡阶段。在此阶段注册的事件监听器会对相应的冒泡事件进行处理</li></ul> <img src="/images/domevent1.png" width="50%"> <p><a href="https://codepen.io/airen/full/oPNxxJ/" target="_blank" rel="noopener noreferrer">事件捕获demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://codepen.io/airen/full/YOzGxv/" target="_blank" rel="noopener noreferrer">事件冒泡demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>事件中断</code></p> <blockquote><p>在JavaScript中可以在事件对象上使用stopPropagation方法。阻止事件在各个阶段中运行。</p></blockquote> <img src="/images/domevent2.png" width="50%"> <p><code>停止即时传播</code></p> <blockquote><p><code>stopImmediatePropagation</code>会立即停止，甚至阻止了当前监听器的兄弟姐妹接收事件。</p></blockquote> <blockquote><p>如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了 event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。</p></blockquote> <p><code>阻止默认行为</code></p> <blockquote><p>preventDefault它是事件对象（Event）的一个方法，作用是取消一个目标元素的默认行为。既然是默认行为，那就说元素必须要有默认行为才能被取消，如果元素自身没有默认行为，调用该方法就会无效。event.cancelable属性来判断一个事件的默认动作是否可以被取消. 在cancelable属性为false的事件上调用 preventDefault 方法没有任何效果。不会阻止冒泡。</p></blockquote> <ul><li><a href="https://www.kirupa.com/html5/event_capturing_bubbling_javascript.htm" target="_blank" rel="noopener noreferrer">Event Capturing and Bubbling in JavaScript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow" target="_blank" rel="noopener noreferrer">Document Object Model (DOM) Level 2 Events Specification<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.sitepoint.com/event-bubbling-javascript/" target="_blank" rel="noopener noreferrer">What Is Event Bubbling in JavaScript? Event Propagation Explained<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://dom.spec.whatwg.org/#events" target="_blank" rel="noopener noreferrer">W3C DOM4 – Events<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture" target="_blank" rel="noopener noreferrer">W3C UI Events – DOM Event Architecture<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events" target="_blank" rel="noopener noreferrer">MSN – Events and the DOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h4 id="参考"><a href="#参考" aria-hidden="true" class="header-anchor">#</a> 参考</h4> <ul><li><a href="https://www.w3cplus.com/javascript/dom-event-intro.html" target="_blank" rel="noopener noreferrer">DOM事件简介<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3cplus.com/javascript/dom-model.html" target="_blank" rel="noopener noreferrer">DOM事件模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3cplus.com/javascript/DOM-event-binding.html" target="_blank" rel="noopener noreferrer">事件绑定的姿势<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3cplus.com/javascript/event-capturing-bubbling-javascript.html" target="_blank" rel="noopener noreferrer">DOM事件的传播<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.w3.org/TR/DOM-Level-3-Events/#ui-events-intro" target="_blank" rel="noopener noreferrer">ui-events-intro<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://time.geekbang.org/column/article/90485" target="_blank" rel="noopener noreferrer">浏览器事件: 为什么会有捕获过程和冒泡过程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/js/jsFunction.html" class="prev">
          js 高级技巧
        </a></span> <span class="next"><a href="/js/domEventPatch.html">
          封装通用事件绑定函数
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a5f12e3f.js" defer></script><script src="/assets/js/2.012767ec.js" defer></script><script src="/assets/js/31.2617bdab.js" defer></script>
  </body>
</html>
