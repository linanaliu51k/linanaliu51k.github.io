<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解js原型链 | 技术分享</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.6c495ada.css" as="style"><link rel="preload" href="/assets/js/app.a5f12e3f.js" as="script"><link rel="preload" href="/assets/js/2.012767ec.js" as="script"><link rel="preload" href="/assets/js/35.9656c028.js" as="script"><link rel="prefetch" href="/assets/js/10.11845e8d.js"><link rel="prefetch" href="/assets/js/11.cda97d54.js"><link rel="prefetch" href="/assets/js/12.26a5fa04.js"><link rel="prefetch" href="/assets/js/13.e5412671.js"><link rel="prefetch" href="/assets/js/14.ce9d5328.js"><link rel="prefetch" href="/assets/js/15.36883b01.js"><link rel="prefetch" href="/assets/js/16.eab308d6.js"><link rel="prefetch" href="/assets/js/17.1bedb10d.js"><link rel="prefetch" href="/assets/js/18.86655160.js"><link rel="prefetch" href="/assets/js/19.3c121154.js"><link rel="prefetch" href="/assets/js/20.66014292.js"><link rel="prefetch" href="/assets/js/21.9b704246.js"><link rel="prefetch" href="/assets/js/22.79fb5d61.js"><link rel="prefetch" href="/assets/js/23.dd836561.js"><link rel="prefetch" href="/assets/js/24.b2cb9a0e.js"><link rel="prefetch" href="/assets/js/25.7ded2382.js"><link rel="prefetch" href="/assets/js/26.a858d3c2.js"><link rel="prefetch" href="/assets/js/27.6554e35b.js"><link rel="prefetch" href="/assets/js/28.dc59e70d.js"><link rel="prefetch" href="/assets/js/29.8ae6ac0b.js"><link rel="prefetch" href="/assets/js/3.91688b6b.js"><link rel="prefetch" href="/assets/js/30.158b3697.js"><link rel="prefetch" href="/assets/js/31.2617bdab.js"><link rel="prefetch" href="/assets/js/32.12fd8296.js"><link rel="prefetch" href="/assets/js/33.1fb3a562.js"><link rel="prefetch" href="/assets/js/34.861e72c8.js"><link rel="prefetch" href="/assets/js/36.a8eff3ec.js"><link rel="prefetch" href="/assets/js/37.09f7437c.js"><link rel="prefetch" href="/assets/js/38.0bd7aae9.js"><link rel="prefetch" href="/assets/js/39.c309197e.js"><link rel="prefetch" href="/assets/js/4.c85e84b2.js"><link rel="prefetch" href="/assets/js/40.78f76cb0.js"><link rel="prefetch" href="/assets/js/41.fd73aeb6.js"><link rel="prefetch" href="/assets/js/42.adcd28da.js"><link rel="prefetch" href="/assets/js/43.dad3d073.js"><link rel="prefetch" href="/assets/js/44.5ee75599.js"><link rel="prefetch" href="/assets/js/45.2c4ca62f.js"><link rel="prefetch" href="/assets/js/46.5cd263f5.js"><link rel="prefetch" href="/assets/js/47.e48a9193.js"><link rel="prefetch" href="/assets/js/5.0e5ac005.js"><link rel="prefetch" href="/assets/js/6.c4a7d53e.js"><link rel="prefetch" href="/assets/js/7.dbe0e90b.js"><link rel="prefetch" href="/assets/js/8.880eb801.js"><link rel="prefetch" href="/assets/js/9.5c5f6e8b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6c495ada.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">技术分享</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">技术分享这件小事</a><ul class="sidebar-sub-headers"></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/jsFunction.html" class="sidebar-link">js 高级技巧</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/domEvent.html" class="sidebar-link">理解dom事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件简介" class="sidebar-link">DOM事件简介</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件模型" class="sidebar-link">DOM事件模型</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件绑定" class="sidebar-link">DOM事件绑定</a></li><li class="sidebar-sub-header"><a href="/js/domEvent.html#dom事件的传播" class="sidebar-link">DOM事件的传播</a></li></ul></li><li><a href="/js/domEventPatch.html" class="sidebar-link">封装通用事件绑定函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/delayLoad.html" class="sidebar-link">js延迟加载</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/copy.html" class="sidebar-link">js深浅拷贝</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/throttle.html" class="sidebar-link">js节流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/throttle.html#函数防抖-debounce" class="sidebar-link">函数防抖(debounce)</a></li><li class="sidebar-sub-header"><a href="/js/throttle.html#函数节流-throttle" class="sidebar-link">函数节流(throttle)</a></li></ul></li><li><a href="/js/curry.html" class="sidebar-link">函数柯里化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/eventLoop.html" class="sidebar-link">理解浏览器的event loop</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/context.html" class="sidebar-link">Js的执行上下文和执行栈</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/this.html" class="sidebar-link">Js的this关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/stricMode.html" class="sidebar-link">理解严格模式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/prototype.html" class="active sidebar-link">理解js原型链</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/js/inherit.html" class="sidebar-link">理解js继承</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>common</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>design</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="理解js原型链"><a href="#理解js原型链" aria-hidden="true" class="header-anchor">#</a> 理解js原型链</h1> <p><code>2020-04-29 周三</code></p> <blockquote><p>学习计划开始<code>第二十一天</code>，今天的目标是理解js原型链。</p></blockquote> <h3 id="javascript-对象的特征"><a href="#javascript-对象的特征" aria-hidden="true" class="header-anchor">#</a> JavaScript 对象的特征</h3> <p>对象有如下几个特点（参考 Grandy Booch《面向对象分析与设计》）:</p> <ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li> <li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li> <li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li></ul> <blockquote><p>对象具有唯一标识的内存地址，所以具有唯一的标识，任何不同的 JavaScript 对象其实是互不相等的。在 JavaScript 中，将状态和行为统一抽象为“属性”。</p></blockquote> <blockquote><p>JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p></blockquote> <p><strong>JavaScript 对象的两类属性</strong></p> <blockquote><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p></blockquote> <p>第一类属性，数据属性。它比较接近于其它语言的属性概念，数据属性具有四个特征。</p> <ul><li>value：就是属性的值。</li> <li>writable：决定属性能否被赋值。</li> <li>enumerable：决定 for in 能否枚举该属性。</li> <li>configurable：决定该属性能否被删除或者改变特征值</li></ul> <p>第二类属性是访问器（getter/setter）属性，它也有四个特征。</p> <ul><li>getter：函数或 undefined，在取属性值时被调用。</li> <li>setter：函数或 undefined，在设置属性值时被调用。</li> <li>enumerable：决定 for in 能否枚举该属性。</li> <li>configurable：决定该属性能否被删除或者改变特征值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//a和b都是数据属性，但特征值变化了</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, writable: true, enumerable: true, configurable: true}</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 2, writable: false, enumerable: false, configurable: true}</span>
o<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言,因为 JavaScript 的高度动态性的对象系统。</p> <h3 id="javascript-的原型"><a href="#javascript-的原型" aria-hidden="true" class="header-anchor">#</a> JavaScript 的原型</h3> <p>抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，用两条概括：</p> <ul><li>如果所有对象都有私有字段[[prototype]]，就是对象的原型；</li> <li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li></ul> <p>从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为</p> <ul><li>Object.create 根据指定的原型创建新对象，原型可以是 null；</li> <li>Object.getPrototypeOf 获得一个对象的原型；</li> <li>Object.setPrototypeOf 设置一个对象的原型。</li></ul> <h3 id="早期版本中的类与原型"><a href="#早期版本中的类与原型" aria-hidden="true" class="header-anchor">#</a> 早期版本中的类与原型</h3> <blockquote><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了[[class]]属性，以表示它们的类。语言使用者唯一可以访问[[class]]属性的方式是 Object.prototype.toString。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">arg</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> arguments <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>o<span class="token punctuation">,</span> n<span class="token punctuation">,</span> s<span class="token punctuation">,</span> b<span class="token punctuation">,</span> d<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> r<span class="token punctuation">,</span> f<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。</p> <p>在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">&quot;MyObject&quot;</span> <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>new 操作具体做了哪些事情? new 运算接受一个构造器和一组调用参数，实际上做了几件事:</p> <ul><li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li> <li>将 this 和调用参数传给构造器，执行；</li> <li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li></ul> <p>ECMAScript 语言规范中 new 运算符的定义：new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常。</p> <p>实现一个<code>new</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个新的对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 取出第一个参数，该参数就是我们将会传入的构造函数</span>
  <span class="token comment">// arguments会被shift去除第一个参数</span>
  <span class="token keyword">let</span> Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将obj的原型指向构造函数，此时obj可以访问构造函数原型中的属性</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">// 改变构造函数的this的指向，使其指向obj</span>
  <span class="token comment">// 此时obj也可以访问构造函数中的属性了</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 确保 new 出来的是个对象</span>
  <span class="token comment">// 返回的值是什么就return什么出来</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj 
<span class="token punctuation">}</span>
</code></pre></div><p>new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。</p> <p>用构造器模拟类的两种方法:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">c1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>p1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">p2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">c1</span><span class="token punctuation">;</span>
o1<span class="token punctuation">.</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">c2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
c2<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>p1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
c2<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">p2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">c2</span><span class="token punctuation">;</span>
o2<span class="token punctuation">.</span><span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第一种方法是直接在构造器中修改 this，给 this 添加属性。
第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。</p> <p>没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定[[prototype]]的方法。可以用它来实现一个 Object.create 的不完整的 polyfill</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">prototype</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">cls</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  cls<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">cls</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h3> <blockquote><p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p></blockquote> <img src="/images/prototype.png" width="60%"> <p><code>prototype</code></p> <ul><li>这是一个显式原型属性，只有函数才拥有该属性, 基本上所有函数都有这个属性，但是也有一个例外。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以这种方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的</span>
<span class="token keyword">let</span> fun <span class="token operator">=</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">prototype</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>当我们声明一个函数时，这个属性就被自动创建了,并且这个属性的值是一个对象（也就是原型），只有一个属性 constructor</li> <li>constructor 是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了</li></ul> <p><code>_proto_</code></p> <blockquote><p>这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过<code>_proto_</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。</p></blockquote> <p>实例对象的 <em>proto</em> 如何产生的？</p> <blockquote><p>当我们使用 new 操作符时，生成的实例对象拥有了_proto_属性, 在 new 的过程中，新对象被添加了 <em>proto</em> 并且链接到构造函数的原型上。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 这个函数是 Function 的实例对象</span>
<span class="token comment">// function 就是一个语法糖</span>
<span class="token comment">// 内部调用了 new Function(...)</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment">// 这个字面量内部也是使用了 new Object()</span>
</code></pre></div><blockquote><p>对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。</p></blockquote> <p><code>总结</code>:</p> <ul><li>Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建。所以可以这样说所有实例都是对象，但是对象不一定都是实例。Function.prototype是个函数，也可以得出不是所有函数都是 new Function() 产生的。</li> <li>有了 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。<code>Function.__proto__ === Function.prototype</code>,可以理解为其他所有的构造函数都可以通过原型链找到 Function.prototype ，并且 function Function() 本质也是一个函数。</li> <li>Object 是所有对象的爸爸，所有对象都可以通过 <strong>proto</strong> 找到它</li> <li>Function 是所有函数的爸爸，所有函数都可以通过 <strong>proto</strong> 找到它</li> <li>函数的 prototype 是一个对象，也就是原型</li> <li>对象的 <strong>proto</strong> 指向原型， <strong>proto</strong> 将对象和原型连接起来组成了原型链</li> <li>注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题</li> <li>原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。</li></ul> <p><code>属性查找过程</code></p> <blockquote><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。属性未找到，会返回undefined。</p></blockquote> <blockquote><p>在原型链上查找属性比较耗时，对性能有副作用。hasOwnProperty 是 JavaScript 中唯一一个处理属性并且不会遍历原型链的方法。(Object.keys()新增的一个也是这样的方法)。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法。</p></blockquote> <p><code>确定原型和实例的关系</code></p> <div class="tip custom-block"><p>第一种是使用 instanceof 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true</p></div> <div class="tip custom-block"><p>第二种是使用 isPrototypeOf() 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true</p></div> <h3 id="es6-中的类"><a href="#es6-中的类" aria-hidden="true" class="header-anchor">#</a> ES6 中的类</h3> <blockquote><p>ES6 中引入了 class 关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。</p></blockquote> <blockquote><p>类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。最重要的是，类提供了继承能力</p></blockquote> <h4 id="参考"><a href="#参考" aria-hidden="true" class="header-anchor">#</a> 参考</h4> <ul><li><a href="https://time.geekbang.org/column/article/79319" target="_blank" rel="noopener noreferrer">JavaScript对象：面向对象还是基于对象？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://time.geekbang.org/column/article/79539" target="_blank" rel="noopener noreferrer">JavaScript对象：我们真的需要模拟类吗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener noreferrer">JS原型链与继承别再被问倒了(推荐)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.cnblogs.com/TomXu/archive/2012/01/05/2305453.html" target="_blank" rel="noopener noreferrer">强大的原型和原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/amandakelake/blog/issues/39" target="_blank" rel="noopener noreferrer">深入原型和原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener noreferrer">深度解析原型中的各个难点(推荐)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/mqyqingfeng/blog/issues/2" target="_blank" rel="noopener noreferrer">JavaScript深入之从原型到原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener noreferrer">继承与原型链<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/js/stricMode.html" class="prev">
          理解严格模式
        </a></span> <span class="next"><a href="/js/inherit.html">
          理解js继承
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a5f12e3f.js" defer></script><script src="/assets/js/2.012767ec.js" defer></script><script src="/assets/js/35.9656c028.js" defer></script>
  </body>
</html>
