(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{221:function(e,a,t){"use strict";t.r(a);var r=t(0),o=Object(r.a)({},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"理解浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#理解浏览器缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 理解浏览器缓存")]),e._v(" "),t("p",[t("code",[e._v("2020-04-26 周日")])]),e._v(" "),t("blockquote",[t("p",[e._v("学习计划开始"),t("code",[e._v("第十九天")]),e._v("，今天的目标是理解浏览器缓存。")])]),e._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("blockquote",[t("p",[e._v("良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。通常浏览器缓存策略分为两种：强缓存和协商缓存。")])]),e._v(" "),t("p",[t("strong",[e._v("基本原理")])]),e._v(" "),t("ul",[t("li",[e._v("1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。")]),e._v(" "),t("li",[e._v("2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源")]),e._v(" "),t("li",[e._v("3）如果前面两者都没有命中，直接从服务器加载资源")])]),e._v(" "),t("p",[t("strong",[e._v("相同点")]),e._v("\n如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据")]),e._v(" "),t("p",[t("strong",[e._v("不同点")]),e._v("\n强缓存不发请求到服务器，协商缓存会发请求到服务器。")]),e._v(" "),t("h3",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),t("blockquote",[t("p",[e._v("强缓存通过Expires和Cache-Control两种响应头实现。如果缓存没有命中，浏览器直接从服务器加载资源时，Expires/Cache-Control Header在重新加载的时候会被更新。")])]),e._v(" "),t("p",[t("strong",[e._v("Expires")])]),e._v(" "),t("blockquote",[t("p",[e._v("Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Expires: Wed, 11 May 2018 07:20:00 GMT\n")])])]),t("p",[t("strong",[e._v("Cache-Control")])]),e._v(" "),t("blockquote",[t("p",[e._v("Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Cache-Control: max-age=315360000\n")])])]),t("p",[e._v("它的一些值")]),e._v(" "),t("blockquote",[t("ul",[t("li",[t("code",[e._v("Cache-Control: no-cache")]),e._v("设置了 no-cache 之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改")]),e._v(" "),t("li",[t("code",[e._v("Cache-Control: no-store")]),e._v("才是真正的不缓存数据到本地")]),e._v(" "),t("li",[t("code",[e._v("Cache-Control: public")]),e._v("可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器")]),e._v(" "),t("li",[t("code",[e._v("Cache-Control: private")]),e._v("只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存")])])]),e._v(" "),t("img",{attrs:{src:e.$withBase("/images/browser-cache2.png"),width:"60%"}}),e._v(" "),t("h3",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),t("blockquote",[t("p",[e._v("当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。")])]),e._v(" "),t("blockquote",[t("p",[e._v("协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的")])]),e._v(" "),t("ul",[t("li",[e._v("Last-Modified，If-Modified-Since")])]),e._v(" "),t("blockquote",[t("p",[e._v("Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag。")])]),e._v(" "),t("p",[t("code",[e._v("注意")]),e._v(": 服务器返回304时的response header中不会再添加Last-Modified。因为资源未更新。")]),e._v(" "),t("ul",[t("li",[e._v("ETag、If-None-Match")])]),e._v(" "),t("blockquote",[t("p",[e._v("Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的。If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来。ETag的优先级比Last-Modified更高。")])]),e._v(" "),t("p",[e._v("具体为什么要用ETag，主要出于下面几种情况考虑:")]),e._v(" "),t("ul",[t("li",[e._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；")]),e._v(" "),t("li",[e._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；")]),e._v(" "),t("li",[e._v("某些服务器不能精确的得到文件的最后修改时间。")])]),e._v(" "),t("p",[t("code",[e._v("注意")]),e._v(": 与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。")]),e._v(" "),t("h3",{attrs:{id:"整体流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体流程图","aria-hidden":"true"}},[e._v("#")]),e._v(" 整体流程图")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/images/browser-cache1.png"),width:"60%"}}),e._v(" "),t("h3",{attrs:{id:"几种状态码的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#几种状态码的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 几种状态码的区别")]),e._v(" "),t("ul",[t("li",[e._v("200：强缓Expires/Cache-Control存失效时，返回新的资源文件")]),e._v(" "),t("li",[e._v("200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功")]),e._v(" "),t("li",[e._v("304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304")])]),e._v(" "),t("p",[e._v("现在的200(from cache)已经变成了from disk cache(磁盘缓存)和from memory cache(内存缓存)两种。")]),e._v(" "),t("h3",{attrs:{id:"如何选择合适的缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何选择合适的缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何选择合适的缓存")]),e._v(" "),t("p",[e._v("大致的顺序")]),e._v(" "),t("ul",[t("li",[e._v("Cache-Control —— 请求服务器之前")]),e._v(" "),t("li",[e._v("Expires —— 请求服务器之前")]),e._v(" "),t("li",[e._v("If-None-Match (Etag) —— 请求服务器")]),e._v(" "),t("li",[e._v("If-Modified-Since (Last-Modified) —— 请求服务器")])]),e._v(" "),t("blockquote",[t("p",[e._v("协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】")])]),e._v(" "),t("p",[e._v("但是下面的场景需要注意：")]),e._v(" "),t("ul",[t("li",[e._v("分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；")]),e._v(" "),t("li",[e._v("分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；")])]),e._v(" "),t("h4",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/amandakelake/blog/issues/41",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器缓存机制：强缓存、协商缓存"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/lyzg/p/5125934.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器缓存知识小结及应用"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.alloyteam.com/2016/03/discussion-on-web-caching/",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈 Web 缓存"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP 缓存"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/entry/5ad86c16f265da505a77dca4",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底理解浏览器的缓存机制"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP 缓存"),t("OutboundLink")],1)])])])},[],!1,null,null,null);a.default=o.exports}}]);