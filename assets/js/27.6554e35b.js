(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{240:function(t,n,a){"use strict";a.r(n);var s=a(0),e=Object(s.a)({},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"js的执行上下文和执行栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js的执行上下文和执行栈","aria-hidden":"true"}},[t._v("#")]),t._v(" Js的执行上下文和执行栈")]),t._v(" "),a("p",[a("code",[t._v("2020-04-21 周二")])]),t._v(" "),a("blockquote",[a("p",[t._v("学习计划开始"),a("code",[t._v("第十六天")]),t._v("，今天的目标是理解浏览器的"),a("code",[t._v("Js的执行上下文和执行栈")]),t._v("。")])]),t._v(" "),a("p",[t._v("以下一些关键词: 闭包；作用域链；执行上下文；this 值等都是涉及函数执行过程相关的知识。")]),t._v(" "),a("h3",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("img",{attrs:{src:t.$withBase("/images/jsContext2.png"),width:"80%"}}),t._v(" "),a("p",[t._v("古典的闭包定义中，闭包包含两个部分:")]),t._v(" "),a("ul",[a("li",[t._v("环境部分--包含 环境 和 标识符 列表")]),t._v(" "),a("li",[t._v("表达式部分")])]),t._v(" "),a("p",[t._v("在 JavaScript 中找到对应的闭包组成部分:")]),t._v(" "),a("ul",[a("li",[t._v("环境部分")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("环境：函数的词法环境（执行上下文的一部分）")]),t._v(" "),a("li",[t._v("标识符列表：函数中用到的未声明的变量")])])]),t._v(" "),a("ul",[a("li",[t._v("表达式部分: 函数体")])]),t._v(" "),a("h3",{attrs:{id:"执行上下文-执行的基础设施"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文-执行的基础设施","aria-hidden":"true"}},[t._v("#")]),t._v(" 执行上下文: 执行的基础设施")]),t._v(" "),a("blockquote",[a("p",[t._v("JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。")])]),t._v(" "),a("p",[a("strong",[t._v("可执行代码")]),t._v("有三种类型：")]),t._v(" "),a("ul",[a("li",[t._v("全局代码--你的代码首次执行的默认环境。")]),t._v(" "),a("li",[t._v("函数代码--每当进入一个函数内部。")]),t._v(" "),a("li",[t._v("Eval 代码--eval内部的文本被执行时。")])]),t._v(" "),a("p",[a("strong",[t._v("执行上下文在 ES3 中")]),t._v("，包含三个部分")]),t._v(" "),a("ul",[a("li",[t._v("scope：作用域，也常常被叫做作用域链。")]),t._v(" "),a("li",[t._v("variable object：变量对象，用于存储变量的对象。")]),t._v(" "),a("li",[t._v("this value：this 值。")])]),t._v(" "),a("p",[a("strong",[t._v("在 ES5 中")]),t._v("，我们改进了命名方式")]),t._v(" "),a("ul",[a("li",[t._v("lexical environment：词法环境，当获取变量时使用。")]),t._v(" "),a("li",[t._v("variable environment：变量环境，当声明变量时使用。")]),t._v(" "),a("li",[t._v("this value：this 值。")])]),t._v(" "),a("p",[a("strong",[t._v("在 ES2018 中")]),t._v("，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。(建议使用这个最新的标志定义)")]),t._v(" "),a("ul",[a("li",[t._v("lexical environment：词法环境，当获取变量或者 this 值时使用。")]),t._v(" "),a("li",[t._v("variable environment：变量环境，当声明变量时使用。")]),t._v(" "),a("li",[t._v("code evaluation state：用于恢复代码执行位置。")]),t._v(" "),a("li",[t._v("Function：执行的任务是函数时使用，表示正在被执行的函数。")]),t._v(" "),a("li",[t._v("ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。")]),t._v(" "),a("li",[t._v("Realm：使用的基础库和内置对象实例。")]),t._v(" "),a("li",[t._v("Generator：仅生成器上下文有这个属性，表示当前生成器。")])]),t._v(" "),a("h3",{attrs:{id:"创建执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建执行上下文","aria-hidden":"true"}},[t._v("#")]),t._v(" 创建执行上下文")]),t._v(" "),a("blockquote",[a("p",[t._v("在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]],这个动作就是切换上下文。")])]),t._v(" "),a("p",[t._v("以下是基于es5版本的介绍")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("创建阶段")])])]),t._v(" "),a("blockquote",[a("p",[t._v("在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事")])]),t._v(" "),a("ul",[a("li",[t._v("this绑定")])]),t._v(" "),a("blockquote",[a("p",[t._v("在全局执行上下文中，this的值指向全局对象; 在函数执行上下文中，调用函数时使用的引用，决定了函数执行时刻的 this 值。")])]),t._v(" "),a("blockquote",[a("p",[t._v("this 是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性, 有三个取值")]),t._v(" "),a("ul",[a("li",[t._v("lexical：表示从上下文中找 this，这对应了箭头函数。")]),t._v(" "),a("li",[t._v("global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。")]),t._v(" "),a("li",[t._v("strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。\n"),a("code",[t._v("注意")]),t._v(": 方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层 this。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\no"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// o, o, o")]),t._v("\n")])])]),a("ul",[a("li",[t._v("创建"),a("strong",[t._v("词法环境")])])]),t._v(" "),a("blockquote",[a("p",[t._v("词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用outer词法环境的空值组成，即：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("环境记录器")]),t._v("是存储变量和函数声明的实际位置。在"),a("strong",[t._v("全局环境")]),t._v("中，环境记录器是对象环境记录器。在"),a("strong",[t._v("函数环境")]),t._v("中,环境记录器是声明式环境记录器。")]),t._v(" "),a("li",[a("strong",[t._v("外部环境的引用")]),t._v("意味着它可以访问其父级词法环境（作用域）(类似es3)")])])]),t._v(" "),a("ul",[a("li",[t._v("创建"),a("strong",[t._v("变量环境")])])]),t._v(" "),a("blockquote",[a("p",[t._v("它同样是一个词法环境，其环境记录器持有"),a("strong",[t._v("变量声明语句")]),t._v("在执行上下文中创建的绑定关系。变量环境也是一个词法环境，它有着词法环境的所有属性。在 ES6 中，"),a("strong",[t._v("词法环境")]),t._v("和"),a("strong",[t._v("变量环境")]),t._v("的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ExecutionContext = {\n  ThisBinding = <this value>,\n  LexicalEnvironment = { ... },\n  VariableEnvironment = { ... },\n}\n")])])]),a("p",[a("code",[t._v("示例代码")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("multiply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" g "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" e "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" f "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" g"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nc "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("multiply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("执行上下文看起来像这样:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 全局执行上下文\nGlobalExectionContext = {\n  ThisBinding: <Global Object>,\n  LexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: "Object",\n      // 在这里绑定标识符 let const funciton等定义的\n      a: < uninitialized >,\n      b: < uninitialized >,\n      multiply: < func >\n    }\n    outer: <null>\n  },\n  VariableEnvironment: {\n    EnvironmentRecord: {\n      Type: "Object",\n      // 在这里绑定标识符 var声明的\n      c: undefined,\n    }\n    outer: <null>\n  }\n}\n// 函数执行上下文\nFunctionExectionContext = {\n  ThisBinding: <Global Object>,\n  LexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: "Declarative",\n      // 在这里绑定标识符\n      Arguments: {0: 20, 1: 30, length: 2},\n    },\n    outer: <GlobalLexicalEnvironment>\n  },\n  VariableEnvironment: {\n    EnvironmentRecord: {\n      Type: "Declarative",\n      // 在这里绑定标识符\n      g: undefined\n    },\n    outer: <GlobalLexicalEnvironment>\n  }\n}\n')])])]),a("ul",[a("li",[a("strong",[t._v("执行阶段")])])]),t._v(" "),a("blockquote",[a("p",[t._v("在此阶段，完成对所有这些变量的分配，最后执行代码。")])]),t._v(" "),a("h3",{attrs:{id:"操作this的内置函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作this的内置函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 操作this的内置函数")]),t._v(" "),a("ul",[a("li",[t._v("Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值，这里 call 和 apply 作用是一样的，只是传参方式有区别。")]),t._v(" "),a("li",[t._v("Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数。")]),t._v(" "),a("li",[t._v("call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。它们无法实现改变 this 的能力，但是可以实现传参。")])]),t._v(" "),a("h3",{attrs:{id:"执行栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行栈","aria-hidden":"true"}},[t._v("#")]),t._v(" 执行栈")]),t._v(" "),a("blockquote",[a("p",[t._v("执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）的数据结构，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行处于栈顶的执行上下文的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。")])]),t._v(" "),a("img",{attrs:{src:t.$withBase("/images/jsContext1.jpg"),width:"80%"}}),t._v(" "),a("h4",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://time.geekbang.org/column/article/83302",target:"_blank",rel:"noopener noreferrer"}},[t._v("闭包和执行上下文到底是怎么回事？"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.w3cplus.com/javascript/understanding-scope-in-javascript.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解JavaScript中的作用域"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://m.imooc.com/article/details?article_id=302255",target:"_blank",rel:"noopener noreferrer"}},[t._v("(ES5版)深入理解 JavaScript 执行上下文和执行栈"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.fundebug.com/2019/03/20/understand-javascript-context-and-stack/",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解 JavaScript 执行上下文和执行栈"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/4",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之执行上下文栈"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/",target:"_blank",rel:"noopener noreferrer"}},[t._v("了解JavaScript的执行上下文"),a("OutboundLink")],1)])])])},[],!1,null,null,null);n.default=e.exports}}]);